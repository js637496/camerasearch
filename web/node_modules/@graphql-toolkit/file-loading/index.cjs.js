'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      });
    }
    n['default'] = e;
    return n;
  }
}

const graphql = require('graphql');
const fs = require('fs');
const path = require('path');
const globby = _interopDefault(require('globby'));

const DEFAULT_IGNORED_SCHEMA_EXTENSIONS = ['spec', 'test', 'd', 'map'];
const DEFAULT_SCHEMA_EXTENSIONS = ['gql', 'graphql', 'graphqls', 'ts', 'js'];
const DEFAULT_IGNORED_RESOLVERS_EXTENSIONS = ['spec', 'test', 'd', 'gql', 'graphql', 'graphqls', 'map'];
const DEFAULT_RESOLVERS_EXTENSIONS = ['ts', 'js'];
const DEFAULT_SCHEMA_EXPORT_NAMES = ['typeDefs', 'schema'];
const DEFAULT_RESOLVERS_EXPORT_NAMES = ['resolvers', 'resolver'];
function isDirectory(path) {
    return fs.existsSync(path) && fs.statSync(path).isDirectory();
}
function scanForFiles(globStr, globOptions = {}) {
    return globby.sync(globStr, { absolute: true, ...globOptions });
}
function buildGlob(basePath, extensions, ignoredExtensions = [], recursive) {
    return `${basePath}${recursive ? '/**' : ''}/${ignoredExtensions.length > 0 ? `!(${ignoredExtensions.map(e => '*.' + e).join('|')})` : '*'}+(${extensions.map(e => '*.' + e).join('|')})`;
}
function extractExports(fileExport, exportNames) {
    if (!fileExport) {
        return null;
    }
    if (fileExport.default) {
        for (const exportName of exportNames) {
            if (fileExport.default[exportName]) {
                return fileExport.default[exportName];
            }
        }
        return fileExport.default;
    }
    for (const exportName of exportNames) {
        if (fileExport[exportName]) {
            return fileExport[exportName];
        }
    }
    return fileExport;
}
const LoadSchemaFilesDefaultOptions = {
    ignoredExtensions: DEFAULT_IGNORED_SCHEMA_EXTENSIONS,
    extensions: DEFAULT_SCHEMA_EXTENSIONS,
    useRequire: false,
    requireMethod: null,
    globOptions: {},
    exportNames: DEFAULT_SCHEMA_EXPORT_NAMES,
    recursive: true,
    ignoreIndex: false,
};
function loadSchemaFiles(path$1, options = LoadSchemaFilesDefaultOptions) {
    const execOptions = { ...LoadSchemaFilesDefaultOptions, ...options };
    const relevantPaths = scanForFiles(isDirectory(path$1) ? buildGlob(path$1, execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive) : path$1, options.globOptions);
    return relevantPaths
        .map(path$1 => {
        if (!checkExtension(path$1, options)) {
            return;
        }
        if (isIndex(path$1, execOptions.extensions) && options.ignoreIndex) {
            return false;
        }
        const extension = path.extname(path$1);
        if (extension.endsWith('.js') || extension.endsWith('.ts') || execOptions.useRequire) {
            const fileExports = (execOptions.requireMethod ? execOptions.requireMethod : require)(path$1);
            const extractedExport = extractExports(fileExports, execOptions.exportNames);
            if (extractedExport && extractedExport.kind === 'Document') {
                return graphql.print(extractedExport);
            }
            return extractedExport;
        }
        else {
            return fs.readFileSync(path$1, { encoding: 'utf-8' });
        }
    })
        .filter(v => v);
}
const LoadResolversFilesDefaultOptions = {
    ignoredExtensions: DEFAULT_IGNORED_RESOLVERS_EXTENSIONS,
    extensions: DEFAULT_RESOLVERS_EXTENSIONS,
    requireMethod: null,
    globOptions: {},
    exportNames: DEFAULT_RESOLVERS_EXPORT_NAMES,
    recursive: true,
    ignoreIndex: false,
};
function loadResolversFiles(path, options = LoadResolversFilesDefaultOptions) {
    const execOptions = { ...LoadResolversFilesDefaultOptions, ...options };
    const relevantPaths = scanForFiles(isDirectory(path) ? buildGlob(path, execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive) : path, options.globOptions);
    return relevantPaths
        .map(path => {
        if (!checkExtension(path, options)) {
            return;
        }
        if (isIndex(path, execOptions.extensions) && options.ignoreIndex) {
            return false;
        }
        try {
            const fileExports = (execOptions.requireMethod ? execOptions.requireMethod : require)(path);
            return extractExports(fileExports, execOptions.exportNames);
        }
        catch (e) {
            throw new Error(`Unable to load resolver file: ${path}, error: ${e}`);
        }
    })
        .filter(t => t);
}
const checkExtension = (path, { extensions, ignoredExtensions }) => {
    if (ignoredExtensions) {
        for (const ignoredExtension of ignoredExtensions) {
            if (path.endsWith(ignoredExtension)) {
                return false;
            }
        }
    }
    if (extensions) {
        for (const extension of extensions) {
            if (path.endsWith(extension)) {
                return true;
            }
        }
    }
    else {
        return true;
    }
    return false;
};
async function loadSchemaFilesAsync(path$1, options = LoadSchemaFilesDefaultOptions) {
    const execOptions = { ...LoadSchemaFilesDefaultOptions, ...options };
    const relevantPaths = scanForFiles(isDirectory(path$1) ? buildGlob(path$1, execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive) : path$1, options.globOptions);
    const require$ = (path) => new Promise(function (resolve) { resolve(_interopNamespace(require(path))); });
    return Promise.all(relevantPaths
        .map(async (path$1) => {
        if (!checkExtension(path$1, options)) {
            return;
        }
        if (isIndex(path$1, execOptions.extensions) && options.ignoreIndex) {
            return false;
        }
        const extension = path.extname(path$1);
        if (extension.endsWith('.js') || extension.endsWith('.ts') || execOptions.useRequire) {
            const fileExports = await (execOptions.requireMethod ? execOptions.requireMethod : require$)(path$1);
            const extractedExport = extractExports(fileExports, execOptions.exportNames);
            if (extractedExport && extractedExport.kind === 'Document') {
                return graphql.print(extractedExport);
            }
            return extractedExport;
        }
        else {
            return new Promise((resolve, reject) => {
                fs.readFile(path$1, { encoding: 'utf-8' }, (err, data) => {
                    if (err) {
                        reject(err);
                    }
                    resolve(data);
                });
            });
        }
    })
        .filter(p => p));
}
async function loadResolversFilesAsync(path, options = LoadResolversFilesDefaultOptions) {
    const execOptions = { ...LoadResolversFilesDefaultOptions, ...options };
    const relevantPaths = scanForFiles(isDirectory(path) ? buildGlob(path, execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive) : path, options.globOptions);
    const require$ = (path) => new Promise(function (resolve) { resolve(_interopNamespace(require(path))); });
    return Promise.all(relevantPaths.map(async (path) => {
        if (!checkExtension(path, options)) {
            return;
        }
        if (isIndex(path, execOptions.extensions) && options.ignoreIndex) {
            return false;
        }
        try {
            const fileExports = await (execOptions.requireMethod ? execOptions.requireMethod : require$)(path);
            return extractExports(fileExports, execOptions.exportNames);
        }
        catch (e) {
            throw new Error(`Unable to load resolver file: ${path}, error: ${e}`);
        }
    }));
}
function isIndex(path, extensions = []) {
    const IS_INDEX = /(\/|\\)index\.[^\/\\]+$/i; // (/ or \) AND `index.` AND (everything except \ and /)(end of line)
    return IS_INDEX.test(path) && extensions.some(ext => path.endsWith('.' + ext));
}

exports.loadResolversFiles = loadResolversFiles;
exports.loadResolversFilesAsync = loadResolversFilesAsync;
exports.loadSchemaFiles = loadSchemaFiles;
exports.loadSchemaFilesAsync = loadSchemaFilesAsync;
