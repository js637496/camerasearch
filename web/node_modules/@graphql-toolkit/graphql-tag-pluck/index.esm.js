import { parse } from '@babel/parser';
import { isVariableDeclarator, isIdentifier, isTemplateLiteral, isImportDefaultSpecifier, isImportSpecifier } from '@babel/types';
import { readFileSync } from 'fs';
import { resolve } from 'path';
import traverse from '@babel/traverse';

function generateConfig(code, options) {
    const plugins = [
        'asyncGenerators',
        'bigInt',
        'classProperties',
        'classPrivateProperties',
        'classPrivateMethods',
        ['decorators', { decoratorsBeforeExport: true }],
        'doExpressions',
        'dynamicImport',
        'exportDefaultFrom',
        'exportNamespaceFrom',
        'functionBind',
        'functionSent',
        'importMeta',
        'logicalAssignment',
        'nullishCoalescingOperator',
        'numericSeparator',
        'objectRestSpread',
        'optionalCatchBinding',
        'optionalChaining',
        ['pipelineOperator', { proposal: 'smart' }],
        'throwExpressions',
    ];
    // { all: true } option is bullshit thus I do it manually, just in case
    // I still specify it
    const flowPlugins = [['flow', { all: true }], 'flowComments'];
    // If line has @flow header, include flow plug-ins
    const dynamicFlowPlugins = /^\/\/ *@flow *\n/.test(code) || /^\/\* *@flow *\*\/ *\n/.test(code) ? flowPlugins : [];
    switch (options.fileExt) {
        case '.ts':
            plugins.push('typescript');
            break;
        case '.tsx':
            plugins.push('typescript', 'jsx');
            break;
        // Adding .jsx extension by default because it doesn't affect other syntax features
        // (unlike .tsx) and because people are seem to use it with regular file extensions
        // (e.g. .js) see https://github.com/dotansimha/graphql-code-generator/issues/1967
        case '.js':
            plugins.push('jsx', ...dynamicFlowPlugins);
            break;
        case '.jsx':
            plugins.push('jsx', ...dynamicFlowPlugins);
            break;
        case '.flow.js':
            plugins.push('jsx', ...flowPlugins);
            break;
        case '.flow.jsx':
            plugins.push('jsx', ...flowPlugins);
            break;
        case '.flow':
            plugins.push('jsx', ...flowPlugins);
            break;
        case '.vue':
            plugins.push('vue');
            break;
        default:
            plugins.push('jsx', ...dynamicFlowPlugins);
            break;
    }
    // The _options filed will be used to retrieve the original options.
    // Useful when we wanna get not config related options later on
    return {
        sourceType: 'module',
        plugins,
        allowUndeclaredExports: true,
    };
}

const getExtNameFromFilePath = (filePath) => {
    const partials = filePath.split('.');
    let ext = '.' + partials.pop();
    if (partials.length > 1 && partials[partials.length - 1] == 'flow') {
        ext = '.' + partials.pop() + ext;
    }
    return ext;
};

// Will use the shortest indention as an axis
const freeText = text => {
    if (text instanceof Array) {
        text = text.join('');
    }
    // This will allow inline text generation with external functions, same as ctrl+shift+c
    // As long as we surround the inline text with ==>text<==
    text = text.replace(/( *)==>((?:.|\n)*?)<==/g, (match, baseIndent, content) => {
        return content
            .split('\n')
            .map(line => `${baseIndent}${line}`)
            .join('\n');
    });
    const lines = text.split('\n');
    const minIndent = lines
        .filter(line => line.trim())
        .reduce((minIndent, line) => {
        const currIndent = line.match(/^ */)[0].length;
        return currIndent < minIndent ? currIndent : minIndent;
    }, Infinity);
    return lines
        .map(line => line.slice(minIndent))
        .join('\n')
        .trim()
        .replace(/\n +\n/g, '\n\n');
};

const defaults = {
    modules: [
        {
            name: 'graphql-tag',
        },
        {
            name: 'graphql-tag.macro',
        },
        {
            name: '@apollo/client',
            identifier: 'gql',
        },
        {
            name: 'gatsby',
            identifier: 'graphql',
        },
        {
            name: 'apollo-server-express',
            identifier: 'gql',
        },
        {
            name: 'apollo-server',
            identifier: 'gql',
        },
        {
            name: 'react-relay',
            identifier: 'graphql',
        },
        {
            name: 'apollo-boost',
            identifier: 'gql',
        },
        {
            name: 'apollo-server-koa',
            identifier: 'gql',
        },
        {
            name: 'apollo-server-hapi',
            identifier: 'gql',
        },
        {
            name: 'apollo-server-fastify',
            identifier: 'gql',
        },
        {
            name: ' apollo-server-lambda',
            identifier: 'gql',
        },
        {
            name: 'apollo-server-micro',
            identifier: 'gql',
        },
        {
            name: 'apollo-server-azure-functions',
            identifier: 'gql',
        },
        {
            name: 'apollo-server-cloud-functions',
            identifier: 'gql',
        },
        {
            name: 'apollo-server-cloudflare',
            identifier: 'gql',
        },
        {
            name: 'graphql.macro',
            identifier: 'gql',
        },
    ],
    gqlMagicComment: 'graphql',
};
const createVisitor = (code, out, options = {}) => {
    // Apply defaults to options
    let { modules, globalGqlIdentifierName, gqlMagicComment } = {
        ...defaults,
        ...options,
    };
    // Prevent case related potential errors
    gqlMagicComment = gqlMagicComment.toLowerCase();
    // normalize `name` and `identifier` values
    modules = modules.map(mod => {
        return {
            name: mod.name,
            identifier: mod.identifier && mod.identifier.toLowerCase(),
        };
    });
    globalGqlIdentifierName = globalGqlIdentifierName && globalGqlIdentifierName.toLowerCase();
    // Keep imported identifiers
    // import gql from 'graphql-tag' -> gql
    // import { graphql } from 'gatsby' -> graphql
    // Will result with ['gql', 'graphql']
    const definedIdentifierNames = [];
    // Will accumulate all template literals
    const gqlTemplateLiterals = [];
    // Check if package is registered
    function isValidPackage(name) {
        return modules.some(pkg => pkg.name && name && pkg.name.toLowerCase() === name.toLowerCase());
    }
    // Check if identifier is defined and imported from registered packages
    function isValidIdentifier(name) {
        return definedIdentifierNames.some(id => id === name) || (globalGqlIdentifierName && name === globalGqlIdentifierName);
    }
    const pluckStringFromFile = ({ start, end }) => {
        return freeText(code
            // Slice quotes
            .slice(start + 1, end - 1)
            // Erase string interpolations as we gonna export everything as a single
            // string anyways
            .replace(/\$\{[^}]*\}/g, '')
            .split('\\`')
            .join('`'));
    };
    // Push all template literals leaded by graphql magic comment
    // e.g. /* GraphQL */ `query myQuery {}` -> query myQuery {}
    const pluckMagicTemplateLiteral = (node, takeExpression = false) => {
        const leadingComments = node.leadingComments;
        if (!leadingComments)
            return;
        if (!leadingComments.length)
            return;
        const leadingComment = leadingComments[leadingComments.length - 1];
        const leadingCommentValue = leadingComment.value.trim().toLowerCase();
        if (leadingCommentValue != gqlMagicComment)
            return;
        const gqlTemplateLiteral = pluckStringFromFile(takeExpression ? node.expression : node);
        if (gqlTemplateLiteral) {
            gqlTemplateLiterals.push(gqlTemplateLiteral);
        }
    };
    return {
        CallExpression: {
            enter(path) {
                // Find the identifier name used from graphql-tag, commonJS
                // e.g. import gql from 'graphql-tag' -> gql
                if (path.node.callee.name == 'require' && isValidPackage(path.node.arguments[0].value)) {
                    if (!isVariableDeclarator(path.parent))
                        return;
                    if (!isIdentifier(path.parent.id))
                        return;
                    definedIdentifierNames.push(path.parent.id.name);
                    return;
                }
                const arg0 = path.node.arguments[0];
                // Push strings template literals to gql calls
                // e.g. gql(`query myQuery {}`) -> query myQuery {}
                if (isIdentifier(path.node.callee) && isValidIdentifier(path.node.callee.name) && isTemplateLiteral(arg0)) {
                    const gqlTemplateLiteral = pluckStringFromFile(arg0);
                    // If the entire template was made out of interpolations it should be an empty
                    // string by now and thus should be ignored
                    if (gqlTemplateLiteral) {
                        gqlTemplateLiterals.push(gqlTemplateLiteral);
                    }
                }
            },
        },
        ImportDeclaration: {
            enter(path) {
                // Find the identifier name used from graphql-tag, es6
                // e.g. import gql from 'graphql-tag' -> gql
                if (!isValidPackage(path.node.source.value))
                    return;
                const moduleNode = modules.find(pkg => pkg.name.toLowerCase() === path.node.source.value.toLowerCase());
                const gqlImportSpecifier = path.node.specifiers.find(importSpecifier => {
                    // When it's a default import and registered package has no named identifier
                    if (isImportDefaultSpecifier(importSpecifier) && !moduleNode.identifier) {
                        return true;
                    }
                    // When it's a named import that matches registered package's identifier
                    if (isImportSpecifier(importSpecifier) && importSpecifier.imported.name === moduleNode.identifier) {
                        return true;
                    }
                    return false;
                });
                if (!gqlImportSpecifier)
                    return;
                definedIdentifierNames.push(gqlImportSpecifier.local.name);
            },
        },
        ExpressionStatement: {
            exit(path) {
                // Push all template literals leaded by graphql magic comment
                // e.g. /* GraphQL */ `query myQuery {}` -> query myQuery {}
                if (!isTemplateLiteral(path.node.expression))
                    return;
                pluckMagicTemplateLiteral(path.node, true);
            },
        },
        TemplateLiteral: {
            exit(path) {
                pluckMagicTemplateLiteral(path.node);
            },
        },
        TaggedTemplateExpression: {
            exit(path) {
                // Push all template literals provided to the found identifier name
                // e.g. gql `query myQuery {}` -> query myQuery {}
                if (!isIdentifier(path.node.tag) || !isValidIdentifier(path.node.tag.name)) {
                    return;
                }
                const gqlTemplateLiteral = pluckStringFromFile(path.node.quasi);
                if (gqlTemplateLiteral) {
                    gqlTemplateLiterals.push(gqlTemplateLiteral);
                }
            },
        },
        exit() {
            out.returnValue = gqlTemplateLiterals.join('\n\n');
        },
    };
};

const gqlExtensions = ['.graphqls', '.graphql', '.gqls', '.gql'];
const jsExtensions = ['.js', '.jsx', '.ts', '.tsx', '.flow', '.flow.js', '.flow.jsx', '.vue'];
const supportedExtensions = [...gqlExtensions, ...jsExtensions];
supportedExtensions.toString = function toString() {
    return this.join(', ');
};
async function pluckVueFileScript(fileData) {
    let vueTemplateCompiler;
    try {
        vueTemplateCompiler = await import('vue-template-compiler');
    }
    catch (e) {
        throw Error(freeText(`
      GraphQL template literals cannot be plucked from a Vue template code without having the "vue-template-compiler" package installed.
      Please install it and try again.

      Via NPM:

          $ npm install vue-template-compiler

      Via Yarn:

          $ yarn add vue-template-compiler
    `));
    }
    const parsed = vueTemplateCompiler.parseComponent(fileData);
    return parsed.script ? parsed.script.content : '';
}
const gqlPluckFromFile = async (filePath, options = {}) => {
    if (typeof filePath != 'string') {
        throw TypeError('Provided file path must be a string');
    }
    const fileExt = getExtNameFromFilePath(filePath);
    if (!supportedExtensions.includes(fileExt)) {
        throw TypeError(`Provided file type must be one of ${supportedExtensions}`);
    }
    if (gqlExtensions.includes(fileExt)) {
        return readFileSync(filePath, { encoding: 'utf8' });
    }
    if (!(options instanceof Object)) {
        throw TypeError(`Options arg must be an object`);
    }
    filePath = resolve(process.cwd(), filePath);
    options = { ...options, fileExt };
    let code = readFileSync(filePath, { encoding: 'utf8' });
    if (fileExt === '.vue') {
        code = await pluckVueFileScript(code);
    }
    return gqlPluckFromCodeString(code, options);
};
const gqlPluckFromCodeString = async (code, options = {}) => {
    if (typeof code != 'string') {
        throw TypeError('Provided code must be a string');
    }
    if (!(options instanceof Object)) {
        throw TypeError(`Options arg must be an object`);
    }
    if (options.fileExt) {
        if (gqlExtensions.includes(options.fileExt)) {
            return code;
        }
        if (!jsExtensions.includes(options.fileExt)) {
            throw TypeError(`options.fileExt must be one of ${supportedExtensions}`);
        }
    }
    const out = { returnValue: null };
    const ast = parse(code, generateConfig(code, options));
    const visitor = createVisitor(code, out, options);
    traverse(ast, visitor);
    return out.returnValue;
};
const index = {
    fromFile: gqlPluckFromFile,
    fromCodeString: gqlPluckFromCodeString,
};

export default index;
export { gqlPluckFromCodeString, gqlPluckFromFile };
