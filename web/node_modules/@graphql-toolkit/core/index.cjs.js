'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      });
    }
    n['default'] = e;
    return n;
  }
}

const graphql = require('graphql');
const common = require('@graphql-toolkit/common');
const path = require('path');
const isGlob = _interopDefault(require('is-glob'));
const globby = _interopDefault(require('globby'));
const schemaMerging = require('@graphql-toolkit/schema-merging');

const filterKind = (content, filterKinds) => {
    if (content && content.definitions && content.definitions.length && filterKinds && filterKinds.length > 0) {
        const invalidDefinitions = [];
        const validDefinitions = [];
        for (const definitionNode of content.definitions) {
            if (filterKinds.includes(definitionNode.kind)) {
                invalidDefinitions.push(definitionNode);
            }
            else {
                validDefinitions.push(definitionNode);
            }
        }
        if (invalidDefinitions.length > 0) {
            invalidDefinitions.forEach(d => {
                common.debugLog(`Filtered document of kind ${d.kind} due to filter policy (${filterKinds.join(', ')})`);
            });
        }
        return {
            kind: graphql.Kind.DOCUMENT,
            definitions: validDefinitions,
        };
    }
    return content;
};

function documentFromString(pointer, filterKinds = []) {
    let content = graphql.parse(pointer);
    const found = [];
    content = filterKind(content, filterKinds);
    if (content && content.definitions && content.definitions.length > 0) {
        found.push({
            location: 'file.graphql',
            document: content,
        });
    }
    return found;
}

function normalizePointers(unnormalizedPointerOrPointers) {
    return common.asArray(unnormalizedPointerOrPointers).reduce((normalizedPointers, unnormalizedPointer) => {
        if (typeof unnormalizedPointer === 'string') {
            normalizedPointers[unnormalizedPointer] = {};
        }
        else if (typeof unnormalizedPointer === 'object') {
            Object.assign(normalizedPointers, unnormalizedPointer);
        }
        else {
            throw new Error(`Invalid pointer ${unnormalizedPointer}`);
        }
        return normalizedPointers;
    }, {});
}
async function getCustomLoaderByPath(path$1, cwd) {
    try {
        const requiredModule = await new Promise(function (resolve) { resolve(_interopNamespace(require(path.join(cwd, path$1)))); });
        if (requiredModule) {
            if (requiredModule.default && typeof requiredModule.default === 'function') {
                return requiredModule.default;
            }
            else if (typeof requiredModule === 'function') {
                return requiredModule;
            }
        }
        return null;
    }
    catch (e) {
        return null;
    }
}
async function loadTypedefsUsingLoaders(loaders, pointerOrPointers, options = {}, filterKinds = [], cwd = process.cwd()) {
    const normalizedPointerOptionsMap = normalizePointers(pointerOrPointers);
    const loadPromises$ = [];
    const found = [];
    const foundGlobs = [];
    const globOptions = {};
    for (const pointer in normalizedPointerOptionsMap) {
        const pointerOptions = normalizedPointerOptionsMap[pointer];
        if (common.isDocumentString(pointer)) {
            loadPromises$.push(Promise.resolve().then(async () => {
                const docs = documentFromString(pointer, filterKinds);
                found.push(...docs);
            }));
        }
        else if (isGlob(pointer)) {
            foundGlobs.push(pointer);
            Object.assign(globOptions, pointerOptions);
        }
        else if (pointerOptions.loader) {
            loadPromises$.push(Promise.resolve().then(async () => {
                let loader;
                if (typeof pointerOptions.loader === 'string') {
                    loader = await getCustomLoaderByPath(pointerOptions.loader, cwd);
                }
                else if (typeof pointerOptions.loader === 'function') {
                    loader = pointerOptions.loader;
                }
                if (typeof loader !== 'function') {
                    throw new Error(`Failed to load custom loader: ${pointerOptions.loader}`);
                }
                let schema;
                let content = await loader(pointer, Object.assign(Object.assign({}, options), pointerOptions), normalizedPointerOptionsMap);
                if (content && content instanceof graphql.GraphQLSchema) {
                    schema = common.fixSchemaAst(content, options);
                    content = graphql.parse(common.printSchemaWithDirectives(content));
                }
                content = filterKind(content, filterKinds);
                if (content && content.definitions && content.definitions.length > 0) {
                    found.push({
                        location: pointer,
                        document: content,
                        schema,
                    });
                }
            }));
        }
        else {
            loadPromises$.push(Promise.resolve().then(async () => {
                const combinedOptions = Object.assign(Object.assign({}, options), pointerOptions);
                let loaded = await loadSingleFile(loaders, pointer, combinedOptions);
                if (loaded) {
                    const filteredDocument = filterKind(loaded.document, filterKinds);
                    if (filteredDocument && filteredDocument.definitions && filteredDocument.definitions.length > 0) {
                        found.push({
                            location: pointer,
                            document: filteredDocument,
                            schema: loaded.schema && common.fixSchemaAst(loaded.schema, combinedOptions),
                        });
                    }
                }
            }));
        }
    }
    if (foundGlobs.length > 0) {
        if (options.ignore) {
            const ignoreList = common.asArray(options.ignore)
                .map(g => `!(${g})`)
                .map(p => common.fixWindowsPath(p));
            if (ignoreList.length > 0) {
                foundGlobs.push(...ignoreList);
            }
        }
        loadPromises$.push(Promise.resolve().then(async () => {
            const paths = await globby(foundGlobs, { cwd, absolute: true });
            await Promise.all(paths.map(async (path) => {
                if (!path.endsWith('.d.ts') && !path.endsWith('.spec.ts') && !path.endsWith('.spec.js') && !path.endsWith('.test.ts') && !path.endsWith('.test.js')) {
                    let content, schema;
                    if (globOptions.loader) {
                        let loader;
                        if (typeof globOptions.loader === 'string') {
                            loader = await getCustomLoaderByPath(globOptions.loader, cwd);
                        }
                        else if (typeof globOptions.loader === 'function') {
                            loader = globOptions.loader;
                        }
                        if (typeof loader !== 'function') {
                            throw new Error(`Failed to load custom loader: ${globOptions.loader}`);
                        }
                        content = await loader(path, Object.assign(Object.assign({}, options), globOptions), normalizedPointerOptionsMap);
                        if (content && content instanceof graphql.GraphQLSchema) {
                            schema = content;
                            content = graphql.parse(common.printSchemaWithDirectives(content));
                        }
                    }
                    else {
                        const loaded = await loadSingleFile(loaders, path, Object.assign(Object.assign({}, options), globOptions));
                        if (loaded) {
                            content = loaded.document;
                            schema = loaded.schema && common.fixSchemaAst(loaded.schema, options);
                        }
                    }
                    content = filterKind(content, filterKinds);
                    if (content && content.definitions && content.definitions.length > 0) {
                        found.push({
                            location: path,
                            document: content,
                            schema,
                        });
                    }
                }
            }));
        }));
    }
    await Promise.all(loadPromises$);
    const pointerList = Object.keys(normalizedPointerOptionsMap);
    if (pointerList.length > 0 && found.length === 0) {
        throw new Error(`Unable to find any GraphQL type definitions for the following pointers: ${pointerList.join(', ')}`);
    }
    return found.sort((left, right) => left.location.localeCompare(right.location));
}
async function loadSingleFile(loaders, pointer, options = {}) {
    try {
        for (const loader of loaders) {
            const canLoad = await loader.canLoad(pointer, options);
            if (canLoad) {
                const found = await loader.load(pointer, options);
                if (found) {
                    return found;
                }
            }
        }
    }
    catch (e) {
        common.debugLog(`Failed to find any GraphQL type definitions in: ${pointer} - ${e.message}`);
        throw e;
    }
    return null;
}

const OPERATION_KINDS = [graphql.Kind.OPERATION_DEFINITION, graphql.Kind.FRAGMENT_DEFINITION];
const NON_OPERATION_KINDS = Object.keys(graphql.Kind)
    .reduce((prev, v) => [...prev, graphql.Kind[v]], [])
    .filter(v => !OPERATION_KINDS.includes(v));
async function loadDocumentsUsingLoaders(loaders, documentDef, options = {}, cwd = process.cwd()) {
    return await loadTypedefsUsingLoaders(loaders, documentDef, Object.assign(Object.assign({}, options), { skipGraphQLImport: true, noRequire: true }), NON_OPERATION_KINDS, cwd);
}

async function loadSchemaUsingLoaders(loaders, schemaPointers, options, cwd = process.cwd()) {
    const sources = await loadTypedefsUsingLoaders(loaders, schemaPointers, options, OPERATION_KINDS, cwd);
    const schemas = [];
    const typeDefs = [];
    for (const source of sources) {
        if (source.schema) {
            schemas.push(source.schema);
        }
        else {
            typeDefs.push(source.document);
        }
    }
    return schemaMerging.mergeSchemasAsync({
        schemas,
        typeDefs,
    });
}

exports.NON_OPERATION_KINDS = NON_OPERATION_KINDS;
exports.OPERATION_KINDS = OPERATION_KINDS;
exports.documentFromString = documentFromString;
exports.filterKind = filterKind;
exports.loadDocumentsUsingLoaders = loadDocumentsUsingLoaders;
exports.loadSchemaUsingLoaders = loadSchemaUsingLoaders;
exports.loadSingleFile = loadSingleFile;
exports.loadTypedefsUsingLoaders = loadTypedefsUsingLoaders;
exports.normalizePointers = normalizePointers;
